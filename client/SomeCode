//design.jsx
import { useState } from "react";
import { FiChevronLeft, FiChevronRight } from "react-icons/fi";
import {
  FoundationType,
  SoilType,
  LoadType,
  InputParameters,
  Results,
  SelectionSummary,
  ResultsDiagram,
} from "../components";

function isEqual(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}

function Design() {
  const [activeTab, setActiveTab] = useState(0);
  const [designData, setDesignData] = useState({
    foundationType: null,
    soilType: null,
    loadType: null,
    inputs: {},
    results: null,
  });

  const tabs = [
    { id: 0, label: "Foundation", component: FoundationType },
    { id: 1, label: "Soil", component: SoilType },
    { id: 2, label: "Load Type", component: LoadType },
    { id: 3, label: "Inputs", component: InputParameters },
    { id: 4, label: "Results", component: Results },
  ];

  const updateDesignData = (key, value) => {
    setDesignData((prev) => {
      if (key === "results" && isEqual(prev.results, value)) {
        return prev;
      }
      return { ...prev, [key]: value };
    });
  };

  const ActiveComponent = tabs[activeTab].component;

  const handleNext = () => {
    if (activeTab < tabs.length - 1) setActiveTab(activeTab + 1);
  };

  const handleBack = () => {
    if (activeTab > 0) setActiveTab(activeTab - 1);
  };

  return (
    <div className="flex flex-col lg:flex-row h-screen bg-gray-100">
      <div className="w-full lg:w-1/2 p-4 overflow-y-auto h-[50vh] lg:h-auto">
        <div className="flex justify-between items-center mb-2">
          <h1 className="text-xl md:text-2xl font-bold text-gray-600">
            Foundation Design
          </h1>
          <div className="text-xs md:text-sm text-gray-500">
            Eurocode (EN) <span className="font-medium">1992-1-1</span>,{" "}
            <span className="font-medium">1997-1</span>
          </div>
        </div>

        <SelectionSummary designData={designData} />

        <div className="flex items-center mb-4 space-x-4">
          <button
            onClick={handleBack}
            disabled={activeTab === 0}
            className={`p-2 rounded-full transition-colors ${
              activeTab === 0
                ? "text-gray-300 cursor-not-allowed"
                : "text-gray-600 hover:bg-gray-100"
            }`}
          >
            <FiChevronLeft className="w-4 h-4 md:w-5 md:h-5 lg:w-6 lg:h-6" />
          </button>

          <div className="flex-1 overflow-x-auto">
            <div className="flex space-x-1 pb-2">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  disabled={
                    (tab.id === 1 && !designData.foundationType) ||
                    (tab.id === 2 && !designData.soilType) ||
                    (tab.id === 3 && !designData.loadType) ||
                    (tab.id === 4 && !designData.inputs)
                  }
                  className={`relative px-4 py-2 text-xs md:text-sm lg:text-base font-medium transition-all duration-200 ${
                    activeTab === tab.id
                      ? "text-[#145da0]"
                      : "text-gray-500 hover:text-gray-700"
                  } ${
                    (tab.id === 1 && !designData.foundationType) ||
                    (tab.id === 2 && !designData.soilType) ||
                    (tab.id === 3 && !designData.loadType) ||
                    (tab.id === 4 && !designData.inputs)
                      ? "opacity-50 cursor-not-allowed"
                      : "cursor-pointer"
                  }`}
                >
                  {tab.label}
                  {activeTab === tab.id && (
                    <span className="absolute bottom-0 left-0 right-0 h-[0.1rem] lg:h-0.5 bg-[#145da0] rounded-full" />
                  )}
                </button>
              ))}
            </div>
          </div>

          <button
            onClick={handleNext}
            disabled={
              (activeTab === 0 && !designData.foundationType) ||
              (activeTab === 1 && !designData.soilType) ||
              (activeTab === 2 && !designData.loadType) ||
              (activeTab === 3 && !designData.inputs) ||
              activeTab === tabs.length - 1
            }
            className={`p-2 rounded-full ${
              (activeTab === 0 && !designData.foundationType) ||
              (activeTab === 1 && !designData.soilType) ||
              (activeTab === 2 && !designData.loadType) ||
              (activeTab === 3 && !designData.inputs) ||
              activeTab === tabs.length - 1
                ? "text-gray-300 cursor-not-allowed"
                : "text-gray-600 hover:bg-gray-200"
            }`}
          >
            <FiChevronRight className="w-4 h-4 md:w-5 md:h-5 lg:w-6 lg:h-6" />
          </button>
        </div>

        <div className="bg-white p-4 md:p-6 rounded-lg shadow-sm border border-gray-200 mb-4 overflow-visible">
          <ActiveComponent
            data={designData}
            updateData={updateDesignData}
            setActiveTab={setActiveTab}
          />
        </div>
      </div>

      <div className="w-full lg:w-1/2 bg-gray-100 border-t lg:border-t-0 lg:border-l border-gray-200 overflow-y-auto h-[50vh] lg:h-auto">
        {activeTab === 4 && designData.results ? (
          <ResultsDiagram
            results={{ ...designData.inputs, ...designData.results }}
          />
        ) : (
          <div className="h-full w-full bg-white border-2 border-dashed border-gray-300 flex items-center justify-center">
            <div className="p-4">
              <span className="text-gray-400 block">Interactive Diagram</span>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default Design;






//foundationtype.jsx
import { FaCube, FaObjectGroup, FaLink } from "react-icons/fa";
import { GiBrickWall } from "react-icons/gi";
import { styles } from "../../styles";
import { GuidanceSection, SelectionBox } from "../";

const foundationTypes = [
  {
    id: "isolated",
    name: "Isolated Footing",
    icon: <FaCube className="text-2xl" />,
    description: "Single column support for stable soils",
    useCase: "Best for: Individual columns with moderate loads",
  },
  {
    id: "combined",
    name: "Combined Footing",
    icon: <FaObjectGroup className="text-2xl" />,
    description: "Supports multiple closely-spaced columns",
    useCase: "Best for: Adjacent columns where isolated footings would overlap",
  },
  {
    id: "strap",
    name: "Strap Footing",
    icon: <FaLink className="text-2xl" />,
    description: "Connected footings with a beam",
    useCase: "Best for: Eccentric loading or property line constraints",
  },
  {
    id: "retaining",
    name: "Retaining Wall",
    icon: <GiBrickWall className="text-2xl" />,
    description: "Supports lateral earth pressure",
    useCase: "Best for: Slope stabilization and basement walls",
  },
];

const guidanceItems = [
  {
    main: "Isolated footings are most economical for standard structures.",
    detail: "Saves 15-20% compared to combined footings in typical cases.",
  },
  {
    main: "Choose combined footings when column spacing is less than 2m.",
    detail: "Prevents overlapping stress zones in dense layouts.",
  },
  {
    main: "Strap footings help when one column is near a property line.",
    detail: "The connecting beam redistributes eccentric loads.",
  },
  {
    main: "Retaining walls require special consideration of lateral forces.",
    detail: "Hydrostatic pressure and soil friction must be calculated.",
  },
];

function FoundationType({ data, updateData, setActiveTab }) {
  const handleSelect = (type) => {
    updateData("foundationType", type);
    setActiveTab(1);
  };

  return (
    <div className="max-w-3xl mx-auto">
      <h2 className={`${styles.sectionTitleText}`}>Foundation Type</h2>
      <p className={`${styles.sectionBodyText} mb-6`}>
        Select the foundation type that matches your project requirements
      </p>

      <SelectionBox
        options={foundationTypes}
        selectedValue={data.foundationType}
        onSelect={handleSelect}
      />

      <GuidanceSection
        title="Selection Guidance"
        items={guidanceItems}
        tip="Tip: Soil conditions and load requirements affect foundation selection"
      />
    </div>
  );
}

export default FoundationType;


//soiltype.jsx
import { FaMountain, FaRuler } from "react-icons/fa";
import { styles } from "../../styles";
import { GiWaterDrop, GiPowder } from "react-icons/gi";
import { GuidanceSection, SelectionBox } from "../";

const soilTypes = [
  {
    id: "CUST",
    name: "Custom Bearing Capacity",
    icon: <FaRuler className="text-2xl" />,
    description: "User-specified bearing capacity",
    useCase: "Best for: Pre-calculated or empirical values",
  },
  {
    id: "CU",
    name: "Clay (Undrained)",
    icon: <GiWaterDrop className="text-2xl" />,
    description: "Short-term behavior for all fine-grained soils",
    useCase: "Best for: Silts and clays under immediate loading",
  },
  {
    id: "CD",
    name: "Clay (Drained)",
    icon: <FaMountain className="text-2xl" />,
    description: "Long-term behavior for cohesive soils",
    useCase: "Best for: Consolidated clays and silty clays",
  },
  {
    id: "S",
    name: "Sand",
    icon: <GiPowder className="text-2xl" />,
    description: "Drained behavior for granular materials",
    useCase: "Best for: Sands, gravels, and silty sands",
  },
];

const guidanceItems = [
  {
    main: "Custom option allows direct bearing capacity input.",
    detail:
      "Provide your calculated bearing capacity to bypass automatic calculations.",
  },
  {
    main: "Undrained analysis is conservative for all fine-grained soils.",
    detail:
      "Includes silty clays - uses total stress parameters (Sᵤ) with φ=0.",
  },
  {
    main: "Drained analysis covers long-term conditions.",
    detail:
      "Effective stress parameters (c', φ') work for clays and most silty soils.",
  },
  {
    main: "Sand analysis applies to all granular materials.",
    detail: "For gravels, increase φ' to 35°-45° in input parameters.",
  },
];

function SoilType({ data, updateData, setActiveTab }) {
  const handleSelect = (type) => {
    updateData("soilType", type);
    setActiveTab(2);
  };

  return (
    <div className="max-w-3xl mx-auto">
      <h2 className={`${styles.sectionTitleText}`}>Soil Behavior Type</h2>
      <p className={`${styles.sectionBodyText} mb-6`}>
        Select the soil behavior that matches your site conditions
      </p>

      <SelectionBox
        options={soilTypes}
        selectedValue={data.soilType}
        onSelect={handleSelect}
      />

      <GuidanceSection
        title="Selection Guidance"
        items={guidanceItems}
        tip="Tip: For silty soils, use 'Clay' types and adjust φ' accordingly"
      />
    </div>
  );
}

export default SoilType;

//LoadType.jsx
import { FaBalanceScale, FaCalculator } from "react-icons/fa";
import { styles } from "../../styles";
import { GuidanceSection, SelectionBox } from "../";

const loadTypes = [
  {
    id: "unfactored",
    name: "Unfactored Loads",
    icon: <FaBalanceScale className="text-2xl" />,
    description: "Service loads with separate dead/live components",
    useCase: "Best for: Entering dead and live load components separately",
  },
  {
    id: "factored",
    name: "Factored Loads",
    icon: <FaCalculator className="text-2xl" />,
    description: "Service loads from structural analysis software",
    useCase:
      "Best for: Using service load outputs from ETABS or similar software",
  },
];

const guidanceItems = [
  {
    main: "Unfactored loads allow precise control of load components.",
    detail:
      "Enter dead and live loads separately for accurate working stress calculations.",
  },
  {
    main: "Factored loads should use service combinations from analysis software.",
    detail:
      "Input 1.0DL + 1.0LL combinations directly from ETABS or similar programs.",
  },
  {
    main: "Working stress method applies a global safety factor of 3.0.",
    detail: "Bearing capacity is calculated as q_ultimate divided by 3.0.",
  },
  {
    main: "Moments require separate permanent/variable components when using Unfactored Loads.",
    detail:
      "Enter Mx and My moments with their dead and live load portions individually.",
  },
];

function LoadType({ data, updateData, setActiveTab }) {
  const handleSelect = (type) => {
    updateData("loadType", type);
    setActiveTab(3);
  };

  return (
    <div className="max-w-3xl mx-auto">
      <h2 className={`${styles.sectionTitleText}`}>Load Type</h2>
      <p className={`${styles.sectionBodyText} mb-6`}>
        Select how you want to input your foundation loads
      </p>

      <SelectionBox
        options={loadTypes}
        selectedValue={data.loadType}
        onSelect={handleSelect}
      />

      <GuidanceSection
        title="Selection Guidance"
        items={guidanceItems}
        tip="Tip: The working stress method with global safety factor is currently implemented"
      />
    </div>
  );
}

export default LoadType;




//selectionbox.jsx
import { IoChevronForward } from "react-icons/io5";
import { styles } from "../../styles";

function SelectionBox({ options, selectedValue, onSelect, className = "" }) {
  return (
    <div className={`grid grid-cols-1 gap-4 ${className}`}>
      {options.map((option) => (
        <button
          key={option.id}
          onClick={() => onSelect(option.id)}
          className={`p-5 border-2 rounded-xl text-left transition-all duration-200 flex items-center justify-between ${
            selectedValue === option.id
              ? "border-[#145da0] bg-[#f0f7ff] shadow-md"
              : "border-gray-200 hover:border-[#145da0]/50 hover:bg-[#f0f7ff]/50"
          }`}
        >
          <div className="flex items-start">
            <div className="mr-4 text-[#145da0] mt-1">{option.icon}</div>
            <div>
              <h3 className={`${styles.cardTitle}`}>{option.name}</h3>
              <p className={`${styles.cardDescription}`}>
                {option.description}
              </p>
              <p className={`${styles.cardUseCase}`}>{option.useCase}</p>
            </div>
          </div>
          <IoChevronForward className="text-gray-400 text-xl" />
        </button>
      ))}
    </div>
  );
}

export default SelectionBox;


//guidancesection.jsx
import { useState } from "react";
import { IoChevronForward, IoChevronDown } from "react-icons/io5";
import { Link } from "react-router-dom";

function GuidanceSection({ title, items, tip }) {
  const [isGuidanceVisible, setGuidanceVisible] = useState(false);

  return (
    <div className="mt-8">
      <button
        onClick={() => setGuidanceVisible(!isGuidanceVisible)}
        className="w-full flex items-center justify-between p-4"
        aria-expanded={isGuidanceVisible}
        aria-controls="guidance-content"
      >
        <div className="flex items-center text-[#145da0] hover:text-black">
          <span className="font-medium md:text-[18px] sm:text-[16px] text-[14px]">
            {title}
          </span>
          <span className="ml-2 md:text-[18px] sm:text-[16px] text-[14px]">
            {isGuidanceVisible ? (
              <IoChevronDown className="inline" />
            ) : (
              <IoChevronForward className="inline" />
            )}
          </span>
        </div>
      </button>

      <div
        id="guidance-content"
        className={`transition-[max-height,opacity] duration-300 ease-in-out overflow-hidden ${
          isGuidanceVisible
            ? "max-h-[var(--content-height)] opacity-100"
            : "max-h-0 opacity-0"
        }`}
        aria-hidden={!isGuidanceVisible}
        style={{ "--content-height": "500px" }}
      >
        <div className="px-5 pb-5 space-y-0">
          {items.map((item, index) => (
            <div key={index} className="p-3">
              <div className="flex">
                <div className="flex-shrink-0 mt-0.5 mr-3 text-blue-600">✓</div>
                <div>
                  <p className="font-medium text-gray-800 md:text-[16px] sm:text-[14px] text-[13px]">
                    {item.main}
                  </p>
                  {item.detail && (
                    <p className="mt-1.5 text-gray-600 pl-2 border-l-2 border-blue-200 md:text-[14px] sm:text-[12px] text-[11px]">
                      {item.detail}
                    </p>
                  )}
                </div>
              </div>
            </div>
          ))}

          <div className="mt-4 text-center">
            <Link
              href="#"
              className="text-[#145da0] font-medium hover:text-black transition duration-200 inline-flex items-center tracking-[0.3em] !font-sans px-6 py-2 uppercase"
              style={{
                fontSize: "clamp(0.6rem, 0.8vw, 0.75rem)",
              }}
            >
              Documentation
              <span className="ml-3 font-bold transform translate-y-[-0px] md:text-[14px] sm:text-[12px] text-[11px]">
                →
              </span>
            </Link>
          </div>

          <div className="mt-6 pt-6 border-t border-gray-200">
            <p className="text-gray-500 italic md:text-[14px] sm:text-[12px] text-[11px]">
              {tip}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

export default GuidanceSection;



//inputparamets folder (following 3 files)
//constants.js
// Helper function to generate consistent field definitions
const createField = (id, label, shortLabel, type, placeholder, unit, description, range, options) => ({
  id,
  label,
  shortLabel,
  type,
  placeholder,
  unit,
  tooltip: `${label} - ${description} - Valid values: ${range}`,
  required: true,
  ...(type === 'number' ? { 
    min: range.split('-')[0].trim(), 
    max: range.split('-')[1].split(' ')[0].trim(),
    ...(options?.step && { step: options.step })
  } : {}),
  ...(options?.options ? { options: options.options } : {})
});

// Shared field configurations
const FIELD_TEMPLATES = {
  load: {
    kN: (id, label, shortLabel, range) => 
      createField(id, label, shortLabel, 'number', `e.g. ${range.split('-')[0]}`, 'kN', 
                `Unfactored ${label.toLowerCase()}`, range),
    kNm: (id, label, shortLabel) => 
      createField(id, label, shortLabel, 'number', 'e.g. 50', 'kN-m', 
                `Unfactored ${label.toLowerCase()}`, '-1000-1000 kNm')
  },
  material: {
    strength: (id, label, range, step) => 
      createField(id, label, id, 'number', `e.g. ${range.split('-')[0]}`, 'MPa', 
                `Characteristic ${label.toLowerCase()}`, range, { step }),
    bar: () => 
      createField('bar', 'Rebar Diameter', 'Ø', 'number', 'e.g. 16', 'mm', 
                'Main reinforcement bar size', '12-32 mm', { step: 2 }),
    cover: () => ({
      ...createField('covr', 'Concrete Cover', 'c', 'select', '', '', 
                   'Nominal concrete cover to reinforcement', ''),
      options: [
        { value: "40", label: "40 mm (Footing on lean concrete)" },
        { value: "75", label: "75 mm (Footing on soil)" }
      ]
    })
  },
  geometry: {
    dimension: (id, label, shortLabel) => 
      createField(id, label, shortLabel, 'number', 'e.g. 300', 'mm', 
                `${label} dimension`, '100-1500 mm'),
    spacing: (id, label, shortLabel) => 
      createField(id, label, shortLabel, 'number', 'e.g. 3000', 'mm', 
                `Distance between ${label.toLowerCase()}`, '500-10000 mm')
  },
  soil: {
    depth: () => 
      createField('Df', 'Foundation Depth', 'Df', 'number', 'e.g. 1500', 'mm', 
                'Depth from ground surface to footing base', '100-10000 mm'),
    weight: () => 
      createField('gamma', 'Soil Unit Weight', 'γ', 'number', 'e.g. 18', 'kN/m³', 
                'Unit weight of soil', '1.1-30 kN/m³', { step: 0.1 })
  }
};

// Field definitions
const LOAD_FIELDS = {
  unfactored: [
    FIELD_TEMPLATES.load.kN('DL', 'Permanent Load (Gk)', 'Gk', '200-4100 kN'),
    FIELD_TEMPLATES.load.kN('LL', 'Variable Load (Qk)', 'Qk', '130-2100 kN'),
    FIELD_TEMPLATES.load.kNm('mxp', 'Moment X Permanent', 'Mx,Gk'),
    FIELD_TEMPLATES.load.kNm('mxv', 'Moment X Variable', 'Mx,Qk'),
    FIELD_TEMPLATES.load.kNm('myp', 'Moment Y Permanent', 'My,Gk'),
    FIELD_TEMPLATES.load.kNm('myv', 'Moment Y Variable', 'My,Qk')
  ],
  factored: [
    FIELD_TEMPLATES.load.kN('NED', 'Design Axial Load', 'P', '300-6000 kN'),
    FIELD_TEMPLATES.load.kNm('MXED', 'Design Moment X', 'Mx'),
    FIELD_TEMPLATES.load.kNm('MYED', 'Design Moment Y', 'My')
  ]
};

const MATERIAL_FIELDS = [
  FIELD_TEMPLATES.material.strength('fck', 'Concrete Strength', '25-100 MPa', 5),
  FIELD_TEMPLATES.material.strength('fyk', 'Steel Strength', '100-1000 MPa', 50),
  FIELD_TEMPLATES.material.bar(),
  FIELD_TEMPLATES.material.cover()
];

const GEOMETRY_FIELDS = {
  isolated: [
    FIELD_TEMPLATES.geometry.dimension('colx', 'Column Width X', 'b'),
    FIELD_TEMPLATES.geometry.dimension('coly', 'Column Width Y', 'h')
  ],
  combined: [
    FIELD_TEMPLATES.geometry.dimension('colx1', 'Column 1 Width X', 'b1'),
    FIELD_TEMPLATES.geometry.dimension('coly1', 'Column 1 Width Y', 'h1'),
    FIELD_TEMPLATES.geometry.dimension('colx2', 'Column 2 Width X', 'b2'),
    FIELD_TEMPLATES.geometry.dimension('coly2', 'Column 2 Width Y', 'h2'),
    FIELD_TEMPLATES.geometry.spacing('col_spacing', 'Column Spacing', 'L')
  ],
  strap: [
    FIELD_TEMPLATES.geometry.dimension('col_main', 'Main Column Width', 'bc'),
    FIELD_TEMPLATES.geometry.dimension('col_strap', 'Strap Column Width', 'bs'),
    FIELD_TEMPLATES.geometry.spacing('strap_length', 'Strap Beam Length', 'Ls')
  ],
  retaining: [
    FIELD_TEMPLATES.geometry.dimension('wall_height', 'Wall Height', 'H'),
    FIELD_TEMPLATES.geometry.dimension('wall_thickness', 'Wall Thickness', 't'),
    FIELD_TEMPLATES.geometry.dimension('toe_length', 'Toe Length', 'Lt'),
    FIELD_TEMPLATES.geometry.dimension('heel_length', 'Heel Length', 'Lh')
  ]
};

const SOIL_FIELDS = {
  CU: [
    FIELD_TEMPLATES.soil.depth(),
    createField('CU', 'Undrained Cohesion', 'Cu', 'number', 'e.g. 50', 'kPa', 
              'Soil undrained cohesion/shear strength', '1-1000 kPa'),
    FIELD_TEMPLATES.soil.weight()
  ],
  CD: [
    FIELD_TEMPLATES.soil.depth(),
    createField('c_prime', 'Effective Cohesion', "c'", 'number', 'e.g. 5', 'kPa', 
              'Effective cohesion parameter', '0-200 kPa'),
    createField('phi_prime', 'Friction Angle', "φ'", 'number', 'e.g. 25', '°', 
              'Effective angle of internal friction', '1-70°'),
    FIELD_TEMPLATES.soil.weight()
  ],
  S: [
    FIELD_TEMPLATES.soil.depth(),
    createField('phi_prime', 'Friction Angle', "φ'", 'number', 'e.g. 30', '°', 
              'Effective angle of internal friction', '1-70°'),
    FIELD_TEMPLATES.soil.weight()
  ],
  CUST: [
    createField('bc', 'Bearing Capacity', 'qa', 'number', 'e.g. 200', 'kPa', 
              'Allowable bearing capacity', '50-1000 kPa')
  ]
};

export {
  LOAD_FIELDS as COMMON_FIELDS,
  MATERIAL_FIELDS,
  GEOMETRY_FIELDS,
  SOIL_FIELDS
};


//FormField.jsx
import React, { useState, useEffect, useRef, useCallback } from "react";
import { FaCircleInfo } from "react-icons/fa6";

const FormField = React.memo(({ field, register, errors }) => {
  const [isFocused, setIsFocused] = useState(false);
  const [tooltipStyle, setTooltipStyle] = useState({});
  const [isTooltipVisible, setIsTooltipVisible] = useState(false);
  const tooltipRef = useRef(null);
  const inputRef = useRef(null);

  const updateTooltipPosition = useCallback(() => {
    if (tooltipRef.current) {
      const rect = tooltipRef.current.getBoundingClientRect();
      setTooltipStyle({
        left: `${rect.left}px`,
        bottom: `${window.innerHeight - rect.top + 8}px`,
      });
    }
  }, []);

  useEffect(() => {
    updateTooltipPosition();
    const handleScroll = () => updateTooltipPosition();
    window.addEventListener("scroll", handleScroll, true);
    return () => window.removeEventListener("scroll", handleScroll, true);
  }, [updateTooltipPosition]);

  // Prevent wheel events from changing number inputs when focused
  useEffect(() => {
    const handleWheel = (e) => {
      if (document.activeElement === inputRef.current) {
        e.preventDefault();
      }
    };

    const inputElement = inputRef.current;
    if (inputElement && field.type === "number") {
      inputElement.addEventListener("wheel", handleWheel, { passive: false });
    }

    return () => {
      if (inputElement) {
        inputElement.removeEventListener("wheel", handleWheel);
      }
    };
  }, [field.type]);

  const error = errors[field.id];

  return (
    <div className="mb-4">
      <label
        htmlFor={field.id}
        className="text-gray-600 text-[11px] sm:text-[13px] font-medium block mb-1"
      >
        <div className="flex items-center gap-1.5">
          {field.displayLabel}
          {field.tooltip && (
            <div
              className="relative group"
              ref={tooltipRef}
              style={{ isolation: "isolate" }}
              onMouseEnter={updateTooltipPosition}
              onClick={() => setIsTooltipVisible((prev) => !prev)}
            >
              <FaCircleInfo className="w-3.5 h-3.5 text-gray-500 cursor-help" />
              <div
                className={`absolute z-[9999] ${
                  isTooltipVisible
                    ? "opacity-100 pointer-events-auto"
                    : "opacity-0 pointer-events-none"
                } group-hover:opacity-100 bottom-full left-0 mb-3 px-3 py-3 text-[11px] sm:text-[12.5px] bg-gray-800 text-white rounded min-w-[250px] whitespace-normal break-words transition-all duration-300 ease-out shadow-lg`}
                style={{
                  position: "fixed",
                  maxWidth: "calc(100vw - 2rem)",
                  ...tooltipStyle,
                }}
              >
                <div className="font-bold">{field.label}</div>
                {field.tooltip.split(" - ").map((part, index) => (
                  <div key={index}>{index === 0 ? null : part} </div>
                ))}
                <div className="absolute top-full left-3 w-0 h-0 border-l-8 border-r-8 border-t-8 border-l-transparent border-r-transparent border-t-gray-800" />
              </div>
            </div>
          )}
        </div>
      </label>

      <div className="flex items-stretch">
        <div
          className={`flex-1 border rounded-l-sm overflow-hidden ${
            isFocused
              ? "border-blue-500 ring-1 ring-blue-100"
              : error
              ? "border-red-500"
              : "border-gray-300"
          }`}
        >
          {field.type === "select" ? (
            <select
              id={field.id}
              {...register(field.id, { required: field.required })}
              className="w-full px-3 py-[0.4rem] border-none focus:outline-none text-[11px] sm:text-[13px] leading-tight"
              onFocus={() => setIsFocused(true)}
              onBlur={() => setIsFocused(false)}
            >
              {field.options?.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          ) : (
            <input
              type={field.type}
              id={field.id}
              {...register(field.id, {
                required: field.required && "This field is required",
                min: field.min && {
                  value: field.min,
                  message: `Minimum value is ${field.min}`,
                },
                max: field.max && {
                  value: field.max,
                  message: `Maximum value is ${field.max}`,
                },
                valueAsNumber: field.type === "number",
              })}
              ref={(e) => {
                register(field.id).ref(e); // Properly connect the ref
                inputRef.current = e; // Store ref for our use
              }}
              className="w-full px-3 py-[0.4rem] border-none focus:outline-none text-[11px] sm:text-[13px] leading-tight"
              placeholder={field.placeholder}
              onFocus={() => setIsFocused(true)}
              onBlur={() => setIsFocused(false)}
              step={field.step || "any"}
              onWheel={(e) => field.type === "number" && e.target.blur()}
            />
          )}
        </div>
        {field.unit && (
          <span className="bg-gray-100 px-3 py-[0.4rem] text-gray-600 border-t border-b border-r border-gray-300 rounded-r-sm flex items-center text-[11px] sm:text-[13px] leading-tight">
            {field.unit}
          </span>
        )}
      </div>
      {error && <p className="text-red-500 text-xs mt-1">{error.message}</p>}
    </div>
  );
});

FormField.displayName = "FormField";

export default FormField;



//index.jsx
import { useCallback } from "react";
import { useForm } from "react-hook-form";
import { styles } from "../../../styles";
import FormField from "./FormField";
import {
  COMMON_FIELDS,
  MATERIAL_FIELDS,
  GEOMETRY_FIELDS,
  SOIL_FIELDS,
} from "./constants";

const InputParameters = ({ data, updateData, setActiveTab }) => {
  const { foundationType, soilType, loadType } = data;
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    defaultValues: data.inputs || {},
  });

  const SectionSeparator = ({ title }) => (
    <div className="w-full my-6">
      <h3 className={`${styles.cardTitle} !text-[#008080] mb-2`}>{title}</h3>
      <div className="w-full border-t border-gray-200" />
    </div>
  );

  const getGeometryFields = useCallback(() => {
    return GEOMETRY_FIELDS[foundationType] || [];
  }, [foundationType]);

  const getSoilFields = useCallback(() => {
    return SOIL_FIELDS[soilType] || [];
  }, [soilType]);

  const onSubmit = (formData) => {
    updateData("inputs", formData);
    setActiveTab(4);
  };

  return (
    <div className="max-w-3xl mx-auto">
      <h2 className={`${styles.sectionTitleText}`}>Inputs</h2>
      <p className={`${styles.sectionBodyText} mb-6`}>
        Enter the required parameters for your foundation design
      </p>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <SectionSeparator title="Loads and Moments" />
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {COMMON_FIELDS[loadType].map((field) => (
            <FormField
              key={field.id}
              field={{
                ...field,
                displayLabel: field.shortLabel || field.id,
              }}
              register={register}
              errors={errors}
            />
          ))}
        </div>

        <SectionSeparator title="Geometry" />
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {getGeometryFields().map((field) => (
            <FormField
              key={field.id}
              field={{
                ...field,
                displayLabel: field.shortLabel || field.id,
              }}
              register={register}
              errors={errors}
            />
          ))}
        </div>

        <SectionSeparator title="Soil Properties" />
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {getSoilFields().map((field) => (
            <FormField
              key={field.id}
              field={{
                ...field,
                displayLabel: field.shortLabel || field.id,
              }}
              register={register}
              errors={errors}
            />
          ))}
        </div>

        <SectionSeparator title="Material Properties" />
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {MATERIAL_FIELDS.map((field) => (
            <FormField
              key={field.id}
              field={{
                ...field,
                displayLabel: field.shortLabel || field.id,
              }}
              register={register}
              errors={errors}
            />
          ))}
        </div>

        <div className="flex justify-end mt-8">
          <button
            type="submit"
            className={`${styles.cardTitle} px-6 py-2 bg-[#145da0] text-white rounded-md hover:bg-[#0e4a7c] transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300 focus:ring-offset-2 shadow-sm`}
          >
            Calculate Design
          </button>
        </div>
      </form>
    </div>
  );
};

export default InputParameters;



//Results folder (following 4 files)
//constants.js
// Field formatting constants
export const FIELD_FORMATTING = {
  decimals: 2,
  smallNumberThreshold: 0.0001,
  smallNumberDecimals: 4
};

// Main results table configuration
export const MAIN_RESULTS = [
  { id: 'b', label: 'Width (B)', unit: 'mm' },
  { id: 'l', label: 'Length (L)', unit: 'mm' },
  { id: 'd', label: 'Thickness (D)', unit: 'mm' },
  { id: 'Nxb', label: 'Number of bars, x-direction, bottom (Nxb)', unit: '' },
  { id: 'Nyb', label: 'Number of bars, y-direction, bottom (Nyb)', unit: '' },
  { id: 'Sxb', label: 'Spacing between bars, x-direction, bottom (Sxb)', unit: 'mm' },
  { id: 'Syb', label: 'Spacing between bars, y-direction, bottom (Syb)', unit: 'mm' },
];

// Additional results table configuration
export const ADDITIONAL_RESULTS = [
  { id: 'As', label: 'Reinforcement Area (As)', unit: 'mm²' },
  { id: 'qu', label: 'Ultimate Bearing Capacity (qu)', unit: 'kPa' },
  { id: 'qa', label: 'Allowable Bearing Capacity (qa)', unit: 'kPa' },
  { id: 'fs', label: 'Factor of Safety (FS)', unit: '' },
  { id: 'sig_p', label: 'Maximum Stress (σmax)', unit: 'kPa' },
  { id: 'vrd', label: 'Shear Resistance (vRd)', unit: 'kPa' },
  { id: 'mrd', label: 'Moment Resistance (MRd)', unit: 'kNm' }
];

// Verification checks table configuration
export const VERIFICATION_CHECKS = [
  { id: 'ved_wide', label: 'Wide Beam Shear (vEd)', unit: 'kPa' },
  { id: 'vrd_wide', label: 'Wide Beam Resistance (vRd)', unit: 'kPa' },
  { id: 'ved_punch', label: 'Punching Shear (vEd)', unit: 'kPa' },
  { id: 'vrd_punch', label: 'Punching Resistance (vRd)', unit: 'kPa' },
  { id: 'med', label: 'Design Moment (MEd)', unit: 'kNm' },
  { id: 'mrd', label: 'Moment Resistance (MRd)', unit: 'kNm' }
];

// Geotechnical design table configuration
export const GEOTECHNICAL_ITEMS = [
  { id: 'D_final', label: 'Footing thickness (D)', unit: 'mm' },
  { id: 'gamma_conc', label: 'Concrete Unit Weight (γconc)', unit: 'kN/m³', symbol: 'γ' },
  { id: 'SW_conc', label: 'Self weight of footing (SWconc)', unit: 'kN' },
  { id: 'SW_fill', label: 'Self weight of fill (SWfill)', unit: 'kN' },
  { id: 'DL', label: 'Permanent Load (Gk)', unit: 'kN' },
  { id: 'LL', label: 'Variable Load (Qk)', unit: 'kN' },
  { id: 'p_p', label: 'Service Load (P = [Gk + SWconc + SWfill] + Qk)', unit: 'kN' },
  { id: 'B_final', label: 'Footing Width (B)', unit: 'mm' },
  { id: 'L_final', label: 'Footing Length (L)', unit: 'mm' },
  { id: 'area', label: 'Footing Area (A)', unit: 'm²' },
  { id: 'mx', label: 'Moment X (Mx = Mx,Gk + Mx,Qk)', unit: 'kNm' },
  { id: 'my', label: 'Moment Y (My = My,Gk + My,Qk)', unit: 'kNm' },
  { id: 'ex', label: 'Eccentricity X (ex)', unit: 'mm', decimals: 2 },
  { id: 'ey', label: 'Eccentricity Y (ey)', unit: 'mm', decimals: 2 },
  { id: 'CU', label: 'Undrained Cohesion (Cu)', unit: 'kPa' },
  { id: 'gamma', label: 'Soil Unit Weight (γ)', unit: 'kN/m³', symbol: 'γ' },
  { id: 'Df', label: 'Foundation Depth (Df)', unit: 'mm' },
  { id: 'qu', label: 'Ultimate Bearing Capacity (qu)', unit: 'kPa' },
  { id: 'fs', label: 'Factor of Safety (FS)', unit: '' },
  { id: 'sig_p', label: 'Maximum Stress (σmax)', unit: 'kPa', symbol: 'σ' },
  { id: 'qa', label: 'Allowable Bearing Capacity (qall)', unit: 'kPa' }
];

// Structural design table configuration
export const STRUCTURAL_ITEMS = [
  { id: 'p_s', label: 'Design Load (P = 1.35Gk + 1.5Qk)', unit: 'kN' },
  { id: 'sig_s', label: 'Design Stress (σ)', unit: 'kPa', symbol: 'σ' },
  { id: 'fck', label: 'Concrete Strength (fck)', unit: 'MPa' },
  { id: 'fyk', label: 'Steel Strength (fyk)', unit: 'MPa' }
];

// Shear failure (punching) table configuration
export const SHEAR_PUNCHING_ITEMS = [
  { id: 'd_punch', label: 'Effective Depth (d)', unit: 'mm' },
  { id: 'k_punch', label: 'Size Factor (k)', unit: '' },
  { id: 'rho_final', label: 'Reinforcement Ratio (ρ)', unit: '', decimals: 4, symbol: 'ρ' },
  { id: 'As_punch', label: 'Critical-Section Surface Area (Acs)', unit: 'm²' },
  { id: 'Ap2_punch', label: 'Critical-Section Cross-Sectional Area (Acc)', unit: 'm²' },
  { id: 'vrd_min_punch', label: 'Minimum Shear Resistance (vRd,min)', unit: 'kPa' },
  { id: 'ved_punch', label: 'Design Shear Stress (vEd)', unit: 'kPa' },
  { id: 'vrd_punch', label: 'Shear Resistance (vRd)', unit: 'kPa' },
  { id: 'D_punch', label: 'Required Depth (D)', unit: 'mm' }
];

// Shear failure (wide beam) table configuration
export const SHEAR_WIDE_BEAM_ITEMS = [
  { id: 'd_wide', label: 'Effective Depth (d)', unit: 'mm' },
  { id: 'k_wide', label: 'Size Factor (k)', unit: '' },
  { id: 'rho_final', label: 'Reinforcement Ratio (ρ)', unit: '', decimals: 4, symbol: 'ρ' },
  { id: 'As_wide', label: 'Critical-Section Surface Area (Acs)', unit: 'm²' },
  { id: 'Ap2_wide', label: 'Critical-Section Cross-Sectional Area (Acc)', unit: 'm²' },
  { id: 'vrd_min_wide', label: 'Minimum Shear Resistance (vRd,min)', unit: 'kPa' },
  { id: 'ved_wide', label: 'Design Shear Stress (vEd)', unit: 'kPa' },
  { id: 'vrd_wide', label: 'Shear Resistance (vRd)', unit: 'kPa' },
  { id: 'D_wide', label: 'Required Depth (D)', unit: 'mm' }
];

// Bending moment failure table configuration
export const BENDING_MOMENT_ITEMS = [
  { id: 'd_final', label: 'Effective Depth (d)', unit: 'mm' },
  { id: 'B_final', label: 'Footing Width (B)', unit: 'mm' },
  { id: 'z', label: 'Lever Arm (z)', unit: 'mm' },
  { id: 'rho_min', label: 'Minimum Reinforcement Ratio (ρmin)', unit: '', decimals: 4, symbol: 'ρ' },
  { id: 'rho_final', label: 'Reinforcement Ratio (ρ)', unit: '', decimals: 4, symbol: 'ρ' },
  { id: 'Asmin', label: 'Minimum Reinforcement Area (As,min)', unit: 'mm²' },
  { id: 'med', label: 'Design Moment (MEd)', unit: 'kNm' },
  { id: 'mrd', label: 'Moment Resistance (MRd)', unit: 'kNm' },
  { id: 'As_old', label: 'Required Reinforcement Area (As)', unit: 'mm²' }
];

// Final rounded values table configuration
export const FINAL_VALUES_ITEMS = [
  { id: 'b', label: 'Footing Width (B)', unit: 'mm' },
  { id: 'l', label: 'Footing Length (L)', unit: 'mm' },
  { id: 'd', label: 'Footing Thickness (D)', unit: 'mm' },
  { id: 'Nxb', label: 'Number of bars, x-direction, bottom (Nxb)', unit: '' },
  { id: 'Nyb', label: 'Number of bars, y-direction, bottom (Nyb)', unit: '' },
  { id: 'Sxb', label: 'Spacing between bars, x-direction, bottom (Sxb)', unit: 'mm' },
  { id: 'Syb', label: 'Spacing between bars, y-direction, bottom (Syb)', unit: 'mm' }
];

// Project information items
export const PROJECT_INFO_ITEMS = [
  { id: 'foundationType', label: 'Foundation Type' },
  { id: 'soilType', label: 'Soil Type' },
  { id: 'loadType', label: 'Load Type' }
];

// Input parameters items
export const INPUT_PARAMETERS_ITEMS = [
  { id: 'DL', label: 'Permanent Load (Gk)', unit: 'kN' },
  { id: 'LL', label: 'Variable Load (Qk)', unit: 'kN' },
  { id: 'mxp', label: 'Moment X Permanent (Mx,Gk)', unit: 'kNm' },
  { id: 'mxv', label: 'Moment X Variable (Mx,Qk)', unit: 'kNm' },
  { id: 'myp', label: 'Moment Y Permanent (My,Gk)', unit: 'kNm' },
  { id: 'myv', label: 'Moment Y Variable (My,Qk)', unit: 'kNm' },
  { id: 'colx', label: 'Column Width X (b)', unit: 'mm' },
  { id: 'coly', label: 'Column Width Y (h)', unit: 'mm' },
  { id: 'Df', label: 'Foundation Depth (Df)', unit: 'mm' },
  { id: 'CU', label: 'Undrained Cohesion (Cu)', unit: 'kPa' },
  { id: 'gamma', label: 'Soil Unit Weight (γ)', unit: 'kN/m³', symbol: 'γ' },
  { id: 'fck', label: 'Concrete Strength (fck)', unit: 'MPa' },
  { id: 'fyk', label: 'Steel Strength (fyk)', unit: 'MPa' },
  { id: 'bar', label: 'Rebar Diameter (Ø)', unit: 'mm' },
  { id: 'covr', label: 'Concrete Cover (c)', unit: 'mm' }
];

// Type mappings
export const TYPE_MAPPINGS = {
  foundation: {
    isolated: 'Isolated Footing',
    combined: 'Combined Footing',
    strap: 'Strap Footing',
    retaining: 'Retaining Wall'
  },
  soil: {
    CU: 'Clay (Undrained)',
    CD: 'Clay (Drained)',
    S: 'Sand',
    CUST: 'Custom Bearing Capacity'
  },
  load: {
    unfactored: 'Unfactored Loads',
    factored: 'Factored Loads'
  }
};


//DesignReport.jsx
import { useState } from "react";
import { FiDownload } from "react-icons/fi";
import { PDFDownloadLink } from "@react-pdf/renderer";
import { styles } from "../../../styles";
import { IoChevronForward, IoChevronDown } from "react-icons/io5";
import ReportPDF from "./DesignReportPDF";
import {
  GEOTECHNICAL_ITEMS,
  STRUCTURAL_ITEMS,
  SHEAR_PUNCHING_ITEMS,
  SHEAR_WIDE_BEAM_ITEMS,
  BENDING_MOMENT_ITEMS,
  FINAL_VALUES_ITEMS,
} from "./constants";

const formatValue = (value, unit, decimals = 2) => {
  if (value === undefined || value === null) return "N/A";
  const numValue = typeof value === "number" ? value : parseFloat(value);

  if (unit === "" && Math.abs(numValue) < 0.0001) {
    return numValue.toFixed(4);
  }

  if (Number.isInteger(numValue)) {
    return `${numValue} ${unit}`;
  }

  return `${numValue.toFixed(decimals)} ${unit}`;
};

const ParameterTable = ({ title, subheader, items, results }) => {
  return (
    <div className="mb-6">
      {title && (
        <h4 className={`${styles.cardTitle} !text-[#008080] mb-2`}>{title}</h4>
      )}
      <div className="border border-gray-300 rounded-md overflow-hidden">
        <table className="w-full">
          <thead>
            <tr className="bg-gray-100 border-b border-gray-300">
              <th className={`${styles.cardDescription} py-2 px-3 text-left`}>
                {subheader || ""}
              </th>
              <th className={`${styles.cardDescription} py-2 px-3 text-right`}>
                Results
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {items.map((item) => (
              <tr key={item.id} className="hover:bg-gray-50">
                <td className={`${styles.cardDescription} py-2 px-3 w-2/3`}>
                  {item.label}
                </td>
                <td
                  className={`${styles.cardDescription} font-medium py-2 px-3 text-right w-1/3`}
                >
                  {formatValue(results[item.id], item.unit, item.decimals)}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

const DesignReport = ({ data, results }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div className="mt-8">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="w-full flex items-center justify-between p-4"
        aria-expanded={isExpanded}
        aria-controls="design-report-content"
      >
        <div className="flex items-center text-[#145da0] hover:text-black">
          <span className="font-medium md:text-[18px] sm:text-[16px] text-[14px]">
            Design Report
          </span>
          <span className="ml-2 md:text-[18px] sm:text-[16px] text-[14px]">
            {isExpanded ? (
              <IoChevronDown className="inline" />
            ) : (
              <IoChevronForward className="inline" />
            )}
          </span>
        </div>
      </button>

      <div
        id="design-report-content"
        className={`transition-[max-height,opacity] duration-300 ease-in-out overflow-hidden ${
          isExpanded ? "max-h-[5000px] opacity-100" : "max-h-0 opacity-0"
        }`}
        aria-hidden={!isExpanded}
      >
        <div className="space-y-6 mt-4 px-8">
          <h3 className={`${styles.cardTitle} !text-[#008080]`}>
            Geotechnical Design
          </h3>
          <ParameterTable
            items={GEOTECHNICAL_ITEMS}
            results={{ ...data.inputs, ...results }}
          />

          <h3 className={`${styles.cardTitle} !text-[#008080]`}>
            Structural Design
          </h3>
          <ParameterTable
            items={STRUCTURAL_ITEMS}
            results={{ ...data.inputs, ...results }}
          />

          <ParameterTable
            subheader="Shear Failure - Punching"
            items={SHEAR_PUNCHING_ITEMS}
            results={results}
          />

          <ParameterTable
            subheader="Shear Failure - Vertical/Wide Beam"
            items={SHEAR_WIDE_BEAM_ITEMS}
            results={results}
          />

          <ParameterTable
            subheader="Bending Moment Failure"
            items={BENDING_MOMENT_ITEMS}
            results={results}
          />

          <h3 className={`${styles.cardTitle} !text-[#008080]`}>
            Final Rounded Values
          </h3>
          <ParameterTable items={FINAL_VALUES_ITEMS} results={results} />

          <div className="flex flex-col sm:flex-row justify-end gap-4 mt-6">
            <PDFDownloadLink
              document={<ReportPDF data={data} results={results} />}
              fileName={`foundation_design_${new Date()
                .toISOString()
                .replace(/[:.]/g, "-")
                .replace("T", "_")
                .slice(0, 19)}.pdf`}
              className="px-4 py-2 bg-[#145da0] text-white rounded-md hover:bg-[#0e4a7c] flex items-center justify-center transition-colors text-[12px] sm:text-[14px] md:text-[16px]"
            >
              {({ loading }) => (
                <>
                  <FiDownload className="mr-2" />
                  {loading ? "Preparing PDF..." : "Download PDF"}
                </>
              )}
            </PDFDownloadLink>

            <button className="px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 flex items-center justify-center transition-colors text-[12px] sm:text-[14px] md:text-[16px]">
              Save to Database
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DesignReport;




//DesignReportPDF.jsx
import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
  Font,
} from "@react-pdf/renderer";
import InterRegular from "../../../assets/fonts/Inter_18pt-Regular.ttf";
import {
  PROJECT_INFO_ITEMS,
  INPUT_PARAMETERS_ITEMS,
  GEOTECHNICAL_ITEMS,
  STRUCTURAL_ITEMS,
  SHEAR_PUNCHING_ITEMS,
  SHEAR_WIDE_BEAM_ITEMS,
  BENDING_MOMENT_ITEMS,
  FINAL_VALUES_ITEMS,
  TYPE_MAPPINGS,
  FIELD_FORMATTING,
} from "./constants";

Font.register({
  family: "Inter",
  src: InterRegular,
});

const stylesPDF = StyleSheet.create({
  page: { padding: 30, fontFamily: "Helvetica" },
  withSymbols: {
    fontFamily: "Inter",
  },
  header: {
    fontSize: 18,
    marginBottom: 20,
    textAlign: "center",
    fontWeight: "bold",
  },
  section: { marginBottom: 15 },
  sectionTitle: {
    fontSize: 14,
    marginBottom: 8,
    fontWeight: "bold",
    color: "#008080",
  },
  subSectionHeader: {
    fontSize: 10,
    fontWeight: "bold",
    width: "70%",
  },
  tableHeaderText: {
    fontSize: 10,
    fontWeight: "bold",
    width: "30%",
    textAlign: "right",
  },
  row: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 5,
  },
  label: { fontSize: 10, width: "70%" },
  value: { fontSize: 10, width: "30%", textAlign: "right" },
  divider: {
    borderBottomWidth: 1,
    borderBottomColor: "#cccccc",
    marginVertical: 10,
  },
  date: {
    textAlign: "center",
    marginBottom: 15,
    fontSize: 10,
  },
});

const formatValue = (value, unit, decimals = FIELD_FORMATTING.decimals) => {
  if (value === undefined || value === null) return "N/A";
  const numValue = typeof value === "number" ? value : parseFloat(value);

  if (
    unit === "" &&
    Math.abs(numValue) < FIELD_FORMATTING.smallNumberThreshold
  ) {
    return numValue.toFixed(FIELD_FORMATTING.smallNumberDecimals);
  }

  if (Number.isInteger(numValue)) {
    return `${numValue} ${unit}`;
  }

  return `${numValue.toFixed(decimals)} ${unit}`;
};

const renderLabel = (item) => {
  if (!item.symbol) return item.label;

  if (typeof item.label === "string") {
    // Find the position of the symbol in the label
    const symbolPos = item.label.indexOf(item.symbol);

    if (symbolPos === -1) return item.label;

    // Split the label into parts before, at, and after the symbol
    const before = item.label.substring(0, symbolPos);
    const after = item.label.substring(symbolPos + item.symbol.length);

    return (
      <Text>
        {before}
        <Text style={stylesPDF.withSymbols}>{item.symbol}</Text>
        {after}
      </Text>
    );
  }

  return item.label;
};

const ParameterTable = ({
  title,
  subheader,
  items,
  data,
  showResultsHeader = true,
}) => {
  return (
    <View style={stylesPDF.section}>
      {title && <Text style={stylesPDF.sectionTitle}>{title}</Text>}

      <View style={stylesPDF.row}>
        {subheader ? (
          <Text style={stylesPDF.subSectionHeader}>{subheader}</Text>
        ) : showResultsHeader ? (
          <Text style={stylesPDF.subSectionHeader}></Text>
        ) : null}
        {showResultsHeader && (
          <Text style={stylesPDF.tableHeaderText}>
            {title === "Input Parameters"
              ? "Inputs"
              : title === "Project Information"
              ? "Type"
              : "Results"}
          </Text>
        )}
      </View>

      {items.map((item) => (
        <View key={item.id} style={stylesPDF.row}>
          <Text style={stylesPDF.label}>{renderLabel(item)}</Text>
          <Text style={stylesPDF.value}>
            {formatValue(data[item.id], item.unit, item.decimals)}
          </Text>
        </View>
      ))}
    </View>
  );
};

const ReportPDF = ({ data, results }) => {
  const allData = { ...data.inputs, ...results };

  const getProjectInfoValue = (item) => {
    switch (item.id) {
      case "foundationType":
        return (
          TYPE_MAPPINGS.foundation[data.foundationType] || data.foundationType
        );
      case "soilType":
        return TYPE_MAPPINGS.soil[data.soilType] || data.soilType;
      case "loadType":
        return TYPE_MAPPINGS.load[data.loadType] || data.loadType;
      default:
        return allData[item.id];
    }
  };

  return (
    <Document>
      <Page style={stylesPDF.page}>
        <View style={stylesPDF.section}>
          <Text style={stylesPDF.header}>Foundation Design Report</Text>
          <Text style={stylesPDF.date}>
            Generated on {new Date().toLocaleDateString()}
          </Text>

          <View style={stylesPDF.divider} />

          <View style={stylesPDF.section}>
            <Text style={stylesPDF.sectionTitle}>Project Information</Text>
            <View style={stylesPDF.row}>
              <Text style={stylesPDF.subSectionHeader}></Text>
              <Text style={stylesPDF.tableHeaderText}>Type</Text>
            </View>
            {PROJECT_INFO_ITEMS.map((item) => (
              <View key={item.id} style={stylesPDF.row}>
                <Text style={stylesPDF.label}>{item.label}</Text>
                <Text style={stylesPDF.value}>{getProjectInfoValue(item)}</Text>
              </View>
            ))}
          </View>

          <View style={stylesPDF.divider} />

          <ParameterTable
            title="Input Parameters"
            items={INPUT_PARAMETERS_ITEMS}
            data={allData}
          />

          <View style={stylesPDF.divider} />

          <ParameterTable
            title="Geotechnical Design"
            items={GEOTECHNICAL_ITEMS}
            data={allData}
          />

          <View style={stylesPDF.divider} />

          <View style={stylesPDF.section}>
            <Text style={stylesPDF.sectionTitle}>Structural Design</Text>
            <ParameterTable items={STRUCTURAL_ITEMS} data={allData} />
            <ParameterTable
              items={SHEAR_PUNCHING_ITEMS}
              data={results}
              subheader="Shear Failure - Punching"
              showResultsHeader={true}
            />
            <ParameterTable
              items={SHEAR_WIDE_BEAM_ITEMS}
              data={results}
              subheader="Shear Failure - Vertical/Wide Beam"
              showResultsHeader={true}
            />
            <ParameterTable
              items={BENDING_MOMENT_ITEMS}
              data={results}
              subheader="Bending Moment Failure"
              showResultsHeader={true}
            />
          </View>

          <View style={stylesPDF.divider} />

          <ParameterTable
            title="Final Rounded Values"
            items={FINAL_VALUES_ITEMS}
            data={results}
          />
        </View>
      </Page>
    </Document>
  );
};

export default ReportPDF;




//index.jsx
import { useState, useEffect } from "react";
import { styles } from "../../../styles";
import DesignReport from "./DesignReport";
import { MAIN_RESULTS } from "./constants";

const ResultCard = ({ items, results }) => {
  return (
    <div className="border border-gray-200 rounded-md overflow-hidden">
      <table className="w-full">
        <thead>
          <tr className="bg-gray-100 border-b border-gray-200">
            <th className="py-3 px-4"></th>
            <th
              scope="col"
              className={`${styles.cardDescription} py-3 px-4 text-right`}
            >
              Results
            </th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-200">
          {items.map((item) => (
            <tr key={item.id} className="bg-green-50">
              <td className={`${styles.cardDescription} py-3 px-4`}>
                {item.label}
              </td>
              <td
                className={`${styles.cardDescription} font-medium py-3 px-4 text-right`}
              >
                {results[item.id]}
                {item.unit && ` ${item.unit}`}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

const Results = ({ data, updateData }) => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchResults = async () => {
      try {
        if (!data.foundationType || !data.soilType || !data.inputs) {
          throw new Error("Missing required design data");
        }

        const response = await fetch("http://localhost:5000/api/design", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            foundationType: data.foundationType,
            soilType: data.soilType,
            inputs: data.inputs,
          }),
        });

        if (!response.ok) {
          throw new Error(`Calculation failed (Status: ${response.status})`);
        }

        const responseData = await response.json();
        updateData("results", responseData.data);
      } catch (err) {
        setError(err.message);
        updateData("results", null);
      } finally {
        setLoading(false);
      }
    };

    fetchResults();
  }, [data, updateData]);

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-[#145da0]"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-md mx-auto p-6">
        <h2 className={`${styles.sectionTitleText} text-red-600 mb-4`}>
          Error
        </h2>
        <p className="text-red-600 mb-4">{error}</p>
      </div>
    );
  }

  if (!data.results) {
    return (
      <div className="max-w-md mx-auto p-6">
        <h2 className={`${styles.sectionTitleText} mb-4`}>No Results</h2>
        <p className={`${styles.sectionBodyText}`}>
          No results available for the current design.
        </p>
      </div>
    );
  }

  return (
    <div className="max-w-3xl mx-auto">
      <h2 className={`${styles.sectionTitleText}`}>Results</h2>
      <p className={`${styles.sectionBodyText} mb-6`}>
        Review your foundation design results
      </p>

      <div className="mb-8">
        <h3 className={`${styles.cardTitle} !text-[#008080] mb-2`}>
          Design Summary
        </h3>
        <div className="w-full border-t border-gray-200 mb-4" />
        <ResultCard items={MAIN_RESULTS} results={data.results} />
      </div>

      <DesignReport data={data} results={data.results} />
    </div>
  );
};

export default Results;

//ResultsDiagram.jsx
import { useEffect, useRef, useState } from "react";
import { FiDownload } from "react-icons/fi";
import { PDFDownloadLink } from "@react-pdf/renderer";
import DiagramHeader from "./DiagramHeader";
import DrawingPDF from "./DrawingPDF";

const DIAGRAM_ASPECT_RATIO = 3 / 4;
const MAX_DIAGRAM_WIDTH = 1200;
const MAX_DIAGRAM_HEIGHT = MAX_DIAGRAM_WIDTH / DIAGRAM_ASPECT_RATIO;

const ResultsDiagram = ({ results }) => {
  const canvasRef = useRef(null);
  const [imageData, setImageData] = useState(null);

  // Function to capture canvas as image
  const captureCanvasImage = () => {
    if (canvasRef.current) {
      try {
        const dataUrl = canvasRef.current.toDataURL("image/png");
        setImageData(dataUrl);
      } catch (error) {
        console.error("Error capturing canvas image:", error);
      }
    }
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const containerWidth = canvas.parentElement.clientWidth;
    let width = Math.min(containerWidth, MAX_DIAGRAM_WIDTH);
    let height = width / DIAGRAM_ASPECT_RATIO;

    if (height > MAX_DIAGRAM_HEIGHT) {
      height = MAX_DIAGRAM_HEIGHT;
      width = height * DIAGRAM_ASPECT_RATIO;
    }

    canvas.width = width;
    canvas.height = height;
  }, []);

  useEffect(() => {
    if (!results) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    // Clear the canvas completely before redrawing
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Reset all canvas state properties to defaults
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = "black";
    ctx.fillStyle = "black";
    ctx.lineWidth = 1;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 10;

    const b = results.b / 1000;
    const d = results.d / 1000;
    const N = results.N;
    const s = results.s;
    const bar = results.bar;
    const col = results.colx / 1000;
    const coly = results.coly / 1000;
    const cov = parseInt(results.covr);

    const topCov = 75;
    const cur = Math.ceil((d - (cov + topCov) * 0.001) * 100) / 100;
    const barXLen = b - 2 * topCov * 0.001;
    const mul =
      b < 2
        ? 100
        : b < 2.5
        ? 93
        : b < 3
        ? 86
        : b < 3.5
        ? 79
        : b < 4
        ? 72
        : b < 4.5
        ? 65
        : b < 5
        ? 58
        : 51;
    const x = mul * b;
    const y1 = mul * b;
    const y2 = mul * d;
    const xCol = mul * col;
    const yCol = mul * coly;
    const curScaled = mul * cur;
    const horzSpace = 30 + x * 0.4;
    const vertSpace = 50 + y1 * 0.7;
    const xScale = 0.75;
    const y1Scale = 0.75;
    const vsScale = 0.2;
    const vsScaleBar = 0.6;
    const offset1 = 5;
    const offset2 = 20;
    const offset3 = 20;
    const offset5 = 4;
    const colHeight = y1 * 0.23;

    const totalWidth = x + horzSpace;
    const totalHeight = y1 + vertSpace + colHeight + y2;

    const xCor = (canvas.width - totalWidth) / 2;
    const yCorDiv =
      b < 2 ? 6 : b < 3 ? 5.3 : b < 4 ? 4.6 : b < 5 ? 3.9 : b < 6 ? 3.2 : 2.5;
    const yCor = (canvas.height - totalHeight) / yCorDiv;

    const dotRadius = mul * 0.03;
    const offSet7 = 4;
    const barOff = 4;

    ctx.strokeStyle = "black";
    ctx.lineWidth = 1.3;

    // plan view
    ctx.beginPath();
    ctx.rect(xCor, yCor, x, y1);
    ctx.fillStyle = "#999999";
    ctx.fillRect(
      xCor + x * 0.5 - xCol * 0.5,
      yCor + y1 * 0.5 - yCol * 0.5,
      xCol,
      yCol
    );
    ctx.stroke();

    // section view
    ctx.beginPath();
    ctx.moveTo(xCor + x * 0.5 - xCol * 0.5, yCor + y1 + vertSpace);
    ctx.lineTo(xCor + x * 0.5 - xCol * 0.5, yCor + y1 + vertSpace + colHeight);
    ctx.lineTo(xCor, yCor + y1 + vertSpace + colHeight);
    ctx.lineTo(xCor, yCor + y1 + vertSpace + colHeight + y2);
    ctx.lineTo(xCor + x, yCor + y1 + vertSpace + colHeight + y2);
    ctx.lineTo(xCor + x, yCor + y1 + vertSpace + colHeight);
    ctx.lineTo(xCor + x * 0.5 + xCol * 0.5, yCor + y1 + vertSpace + colHeight);
    ctx.lineTo(xCor + x * 0.5 + xCol * 0.5, yCor + y1 + vertSpace);
    ctx.stroke();

    // col bar
    const colBarOff = 4;
    const cOBot = 1.5;
    ctx.beginPath();
    ctx.moveTo(xCor + x * 0.5 - xCol * 0.5 + colBarOff, yCor + y1 + vertSpace);
    ctx.lineTo(
      xCor + x * 0.5 - xCol * 0.5 + colBarOff,
      yCor +
        y1 +
        vertSpace +
        colHeight +
        y2 -
        barOff -
        offSet7 -
        dotRadius -
        cOBot
    );
    ctx.lineTo(
      xCor + x * 0.5 - xCol * 0.5 + colBarOff - curScaled,
      yCor +
        y1 +
        vertSpace +
        colHeight +
        y2 -
        barOff -
        offSet7 -
        dotRadius -
        cOBot
    );
    ctx.moveTo(xCor + x * 0.5 + xCol * 0.5 - colBarOff, yCor + y1 + vertSpace);
    ctx.lineTo(
      xCor + x * 0.5 + xCol * 0.5 - colBarOff,
      yCor +
        y1 +
        vertSpace +
        colHeight +
        y2 -
        barOff -
        offSet7 -
        dotRadius -
        cOBot
    );
    ctx.lineTo(
      xCor + x * 0.5 + xCol * 0.5 - colBarOff + curScaled,
      yCor +
        y1 +
        vertSpace +
        colHeight +
        y2 -
        barOff -
        offSet7 -
        dotRadius -
        cOBot
    );
    ctx.stroke();

    // Column horizontal lines
    const numLns = Math.floor(b) + 2;
    const lineLen =
      xCor +
      x * 0.5 +
      xCol * 0.5 -
      colBarOff -
      (xCor + x * 0.5 - xCol * 0.5 + colBarOff);
    const vertSpacBars = 15;
    const xBSrt = xCor + x * 0.5 - xCol * 0.5 + colBarOff;
    const yBSrt = yCor + y1 + vertSpace + 5;

    ctx.beginPath();
    for (let i = 0; i < numLns; i++) {
      const yPosition = yBSrt + i * vertSpacBars;
      ctx.moveTo(xBSrt, yPosition);
      ctx.lineTo(xBSrt + lineLen, yPosition);
    }
    ctx.stroke();

    // plan view bar and centerline
    // vert rebar
    ctx.beginPath();
    ctx.moveTo(xCor + x * xScale - curScaled, yCor + offset1);
    ctx.lineTo(xCor + x * xScale, yCor + offset1);
    ctx.lineTo(xCor + x * xScale, yCor + y1 - offset1);
    ctx.lineTo(xCor + x * xScale - curScaled, yCor + y1 - offset1);
    ctx.moveTo(xCor + x + horzSpace - curScaled, yCor + offset1);
    ctx.lineTo(xCor + x + horzSpace, yCor + offset1);
    ctx.lineTo(xCor + x + horzSpace, yCor + y1 - offset1);
    ctx.lineTo(xCor + x + horzSpace - curScaled, yCor + y1 - offset1);
    ctx.stroke();

    // horz rebar
    ctx.beginPath();
    ctx.moveTo(xCor + offset1, yCor + y1 * y1Scale - curScaled);
    ctx.lineTo(xCor + offset1, yCor + y1 * y1Scale);
    ctx.lineTo(xCor + x - offset1, yCor + y1 * y1Scale);
    ctx.lineTo(xCor + x - offset1, yCor + y1 * y1Scale - curScaled);
    ctx.moveTo(xCor + offset1, yCor + y1 + vertSpace * vsScaleBar - curScaled);
    ctx.lineTo(xCor + offset1, yCor + y1 + vertSpace * vsScaleBar);
    ctx.lineTo(xCor + x - offset1, yCor + y1 + vertSpace * vsScaleBar);
    ctx.lineTo(
      xCor + x - offset1,
      yCor + y1 + vertSpace * vsScaleBar - curScaled
    );
    ctx.stroke();

    // section view bar
    ctx.beginPath();
    ctx.moveTo(
      xCor + offset1,
      yCor + y1 + vertSpace + colHeight + y2 - barOff - curScaled
    );
    ctx.lineTo(xCor + offset1, yCor + y1 + vertSpace + colHeight + y2 - barOff);
    ctx.lineTo(
      xCor + x - offset1,
      yCor + y1 + vertSpace + colHeight + y2 - barOff
    );
    ctx.lineTo(
      xCor + x - offset1,
      yCor + y1 + vertSpace + colHeight + y2 - barOff - curScaled
    );
    ctx.stroke();

    // centerline plan view and col top
    ctx.beginPath();
    const cenLineOff = 15;
    ctx.moveTo(xCor + x * 0.5, yCor - cenLineOff);
    ctx.lineTo(xCor + x * 0.5, yCor + y1 + cenLineOff);
    ctx.moveTo(xCor - cenLineOff, yCor + y1 * 0.5);
    ctx.lineTo(xCor + x + cenLineOff, yCor + y1 * 0.5);
    ctx.moveTo(
      xCor + x * 0.5 - xCol * 0.5 + colBarOff - 20,
      yCor + y1 + vertSpace
    );
    ctx.lineTo(
      xCor + x * 0.5 + xCol * 0.5 - colBarOff + 20,
      yCor + y1 + vertSpace
    );
    ctx.lineWidth = 0.5;
    ctx.stroke();

    // Draw reinforcement dots
    const numDots = N;
    const xCStart = xCor + offset1 + 4;
    const xCEnd = xCor + x - offset1 - 4;
    const width = xCEnd - xCStart - dotRadius * 2 + offset5;
    const yC = yCor + y1 + vertSpace + colHeight + y2 - barOff - offSet7;
    const spacing = width / (numDots - 1);

    for (let i = 0; i < numDots; i++) {
      let xPos = xCStart + spacing * i;
      if (i === numDots - 1) xPos = xCEnd;
      ctx.beginPath();
      ctx.arc(xPos, yC, dotRadius, 0, 2 * Math.PI);
      ctx.fillStyle = "black";
      ctx.fill();
      ctx.closePath();
    }

    // Draw dimension lines and arrows
    const arrOff1 = 35;
    const arrOff2 = 8;
    const arrOff3 = 15 * x * 0.009;

    const dimensionLines = [
      {
        startX: xCor + x + arrOff1,
        startY: yCor,
        endX: xCor + x + arrOff1,
        endY: yCor + y1,
      },
      {
        startX: xCor,
        startY: yCor + y1 + arrOff1,
        endX: x + xCor,
        endY: yCor + y1 + arrOff1,
      },
      {
        startX: xCor + x + arrOff2,
        startY: yCor + y1 + vertSpace + colHeight + y2,
        endX: xCor + x + arrOff2,
        endY: yCor + y1 + vertSpace + colHeight,
      },
      {
        startX: xCor + x + arrOff2,
        startY: yCor,
        endX: xCor + x + arrOff2,
        endY: yCor + y1 * 0.5,
      },
      {
        startX: xCor + x + arrOff2,
        startY: yCor + y1 * 0.5,
        endX: xCor + x + arrOff2,
        endY: yCor + y1,
      },
      {
        startX: xCor,
        startY: yCor + y1 + arrOff2,
        endX: xCor + x * 0.5,
        endY: yCor + y1 + arrOff2,
      },
      {
        startX: xCor + x * 0.5,
        startY: yCor + y1 + arrOff2,
        endX: xCor + x,
        endY: yCor + y1 + arrOff2,
      },
      {
        startX: xCor,
        startY: yCor + y1 + vertSpace + arrOff3,
        endX: xCor + x * 0.5 - xCol * 0.5,
        endY: yCor + y1 + vertSpace + arrOff3,
      },
      {
        startX: xCor + x * 0.5 - xCol * 0.5,
        startY: yCor + y1 + vertSpace - arrOff2,
        endX: xCor + x * 0.5 + xCol * 0.5,
        endY: yCor + y1 + vertSpace - arrOff2,
      },
      {
        startX: xCor + x * 0.5 + xCol * 0.5,
        startY: yCor + y1 + vertSpace + arrOff3,
        endX: xCor + x,
        endY: yCor + y1 + vertSpace + arrOff3,
      },
    ];

    const lineWidth = 0.9;
    const arrowHeadSize = 5.5;
    const fontSize = 12;
    const fontFamily = "Arial";

    function drawArrowhead(ctx, startX, startY, endX, endY, size) {
      const angle = Math.atan2(endY - startY, endX - startX);
      const headLength = size * 4;
      const headWidth = size * 4;
      const arrowX1 = endX - headLength * Math.cos(angle + Math.PI / 3);
      const arrowY1 = endY - headLength * Math.sin(angle + Math.PI / 3);
      const arrowX2 = endX - headLength * Math.cos(angle - Math.PI / 3);
      const arrowY2 = endY - headLength * Math.sin(angle - Math.PI / 3);
      const offsetX1 = headWidth * Math.cos(angle + Math.PI / 2);
      const offsetY1 = headWidth * Math.sin(angle + Math.PI / 2);
      const offsetX2 = headWidth * Math.cos(angle - Math.PI / 2);
      const offsetY2 = headWidth * Math.sin(angle - Math.PI / 2);

      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(arrowX1 + offsetX1, arrowY1 + offsetY1);
      ctx.lineTo(arrowX2 + offsetX2, arrowY2 + offsetY2);
      ctx.closePath();
      ctx.fillStyle = "black";
      ctx.fill();
    }

    function drawDimensionLine(ctx, lineData) {
      const { startX, startY, endX, endY } = lineData;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = "black";
      ctx.stroke();
      drawArrowhead(ctx, startX, startY, endX, endY, arrowHeadSize);
      drawArrowhead(ctx, endX, endY, startX, startY, arrowHeadSize);
    }

    dimensionLines.forEach((lineData) => drawDimensionLine(ctx, lineData));

    // Draw text labels
    const scaleFont = 1.4;
    let barFontScale = 1.4;
    let offset4 = 40;

    if (b < 2.3) {
      barFontScale = barFontScale < x * 0.01 ? barFontScale : x * 0.01;
      offset4 = x * 0.27;
    }

    function drawText(text, x, y, fontScale, rotation = 0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate((rotation * Math.PI) / 180);
      ctx.font = `${fontScale}px ${fontFamily}`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#000";
      ctx.fillText(text.toString(), 0, 0);
      ctx.restore();
    }

    const txtOff1 = 20;
    const txtOff2 = 48;
    const txtOff3 = 8;
    const txtOff4 = 12;
    const txtOff5 = 20;

    // Draw all text labels
    drawText(
      d * 1000,
      xCor + x + txtOff1,
      yCor + y1 + vertSpace + colHeight + y2 * 0.5,
      fontSize * scaleFont,
      270
    );
    drawText(
      b * 1000,
      xCor + x + txtOff2,
      yCor + y1 * 0.5,
      fontSize * scaleFont,
      270
    );
    drawText(
      b * 500,
      xCor + x + txtOff1,
      yCor + y1 * 0.25,
      fontSize * scaleFont,
      270
    );
    drawText(
      b * 500,
      xCor + x + txtOff1,
      yCor + y1 * 0.75,
      fontSize * scaleFont,
      270
    );
    drawText(
      b * 1000,
      xCor + x * 0.5,
      yCor + y1 + txtOff2,
      fontSize * scaleFont,
      0
    );
    drawText(
      b * 500,
      xCor + x * 0.25,
      yCor + y1 + txtOff1,
      fontSize * scaleFont,
      0
    );
    drawText(
      b * 500,
      xCor + x * 0.75,
      yCor + y1 + txtOff1,
      fontSize * scaleFont,
      0
    );
    drawText(
      Math.round((b * 0.5 - col * 0.5) * 1000),
      xCor + x * 0.21,
      yCor + y1 + vertSpace + arrOff3 - txtOff3,
      fontSize * scaleFont,
      0
    );
    drawText(
      Math.round((b * 0.5 - col * 0.5) * 1000),
      xCor + x * 0.79,
      yCor + y1 + vertSpace + arrOff3 - txtOff3,
      fontSize * scaleFont,
      0
    );
    drawText(
      Math.round(col * 1000),
      xCor + x * 0.5,
      yCor + y1 + vertSpace - arrOff2 - txtOff4,
      fontSize * scaleFont,
      0
    );
    drawText(
      Math.round(col * 1000),
      xCor + x * 0.5,
      yCor + y1 + vertSpace - arrOff2 - txtOff4,
      fontSize * scaleFont,
      0
    );
    drawText(
      N + "ϕ" + bar + "@" + s + "-" + Math.round((2 * cur + barXLen) * 1000),
      xCor + x * 0.5,
      yCor + y1 + vertSpace * vsScaleBar - txtOff4,
      fontSize * barFontScale,
      0
    );
    drawText(
      Math.round(barXLen * 1000),
      xCor + x * 0.5,
      yCor + y1 + vertSpace * vsScaleBar + txtOff4,
      fontSize * barFontScale,
      0
    );
    drawText(
      Math.round(cur * 1000),
      xCor - txtOff3,
      yCor + y1 + vertSpace * vsScaleBar - curScaled * 0.5,
      fontSize * barFontScale,
      270
    );
    drawText(
      Math.round(cur * 1000),
      xCor + x + txtOff3,
      yCor + y1 + vertSpace * vsScaleBar - curScaled * 0.5,
      fontSize * barFontScale,
      270
    );
    drawText(
      N + "ϕ" + bar + "@" + s + "-" + Math.round((2 * cur + barXLen) * 1000),
      xCor + x + horzSpace - txtOff4,
      yCor + y1 * 0.5,
      fontSize * barFontScale,
      270
    );
    drawText(
      Math.round(barXLen * 1000),
      xCor + x + horzSpace + txtOff4,
      yCor + y1 * 0.5,
      fontSize * barFontScale,
      270
    );
    drawText(
      Math.round(cur * 1000),
      xCor + x + horzSpace - curScaled * 0.5,
      yCor - txtOff3,
      fontSize * barFontScale,
      0
    );
    drawText(
      Math.round(cur * 1000),
      xCor + x + horzSpace - curScaled * 0.5,
      yCor + y1 + txtOff3,
      fontSize * barFontScale,
      0
    );
    drawText("A", xCor - txtOff5, yCor + y1 * 0.5, fontSize * scaleFont, 0);
    drawText("A", xCor + x + txtOff5, yCor + y1 * 0.5, fontSize * scaleFont, 0);
    drawText(
      "Section A-A",
      xCor + x * 0.5,
      yCor + y1 + vertSpace + colHeight + y2 + txtOff1,
      fontSize * scaleFont,
      0
    );

    // After drawing is complete, capture the canvas as an image
    captureCanvasImage();
  }, [results]);

  return (
    <div className="p-4 w-full h-full overflow-auto">
      <div className="bg-white border border-gray-200 shadow-sm">
        <DiagramHeader
          title="Engineering Drawing"
          subtitle="UNITS: MILLIMETERS (mm)"
        />
        <canvas
          ref={canvasRef}
          className="w-full"
          style={{
            height: "auto",
            aspectRatio: DIAGRAM_ASPECT_RATIO,
            maxWidth: `${MAX_DIAGRAM_WIDTH}px`,
            maxHeight: `${MAX_DIAGRAM_HEIGHT}px`,
          }}
        />
        <div className="flex justify-end gap-4 p-4">
          {imageData && (
            <PDFDownloadLink
              document={<DrawingPDF imageData={imageData} />}
              fileName={`foundation_drawing_${new Date()
                .toISOString()
                .replace(/[:.]/g, "-")
                .replace("T", "_")
                .slice(0, 19)}.pdf`}
              className="px-4 py-2 bg-[#145da0] text-white rounded-md hover:bg-[#0e4a7c] flex items-center justify-center transition-colors text-[12px] sm:text-[14px] md:text-[16px]"
            >
              {({ loading }) => (
                <>
                  <FiDownload className="mr-2" />
                  {loading ? "Preparing PDF..." : "Download PDF"}
                </>
              )}
            </PDFDownloadLink>
          )}
          <button className="px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 flex items-center justify-center transition-colors text-[12px] sm:text-[14px] md:text-[16px]">
            Save to Database
          </button>
        </div>
      </div>
    </div>
  );
};

export default ResultsDiagram;



//DiagramHeader.jsx
import { styles } from "../../styles";

const DiagramHeader = ({ title, subtitle }) => {
  return (
    <div className="p-6">
      <h2 className={`${styles.sectionTitleText}`}>{title}</h2>
      {subtitle && (
        <p className={`${styles.sectionBodyText} text-gray-600 mt-1`}>
          {subtitle}
        </p>
      )}
    </div>
  );
};

export default DiagramHeader;



//DrawingPdf.jsx
import { Document, Page, View, Image, Text } from "@react-pdf/renderer";

const DrawingPDF = ({ imageData }) => {
  return (
    <Document>
      <Page
        size="A4"
        orientation="landscape"
        style={{
          padding: 20,
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between",
          alignItems: "center",
          height: "100%",
        }}
      >
        <View
          style={{
            width: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexGrow: 1,
          }}
        >
          <Image
            src={imageData}
            style={{
              maxWidth: "1500px",
              maxHeight: "100%",
              objectFit: "contain",
            }}
          />
        </View>
        <View
          style={{
            border: "1pt solid #ccc",
            paddingHorizontal: 8,
            paddingVertical: 4,
            backgroundColor: "#eee",
            borderRadius: 2,
            alignSelf: "flex-end",
            marginTop: 10,
          }}
        >
          <Text style={{ fontSize: 12, fontWeight: "bold", color: "#555" }}>
            UNITS: MILLIMETERS (mm)
          </Text>
        </View>
      </Page>
    </Document>
  );
};

export default DrawingPDF;





//index.js  
import { lazy } from 'react';

export { default as Navbar } from "./Navbar";
export { default as Footer } from "./Footer";
export { default as FeatureCard } from "./FeatureCard";
export { default as WhyChooseCard } from "./WhyChooseCard";
export { default as AdvantageCard } from "./AdvantageCard";
export { default as ComplianceItem } from "./ComplianceItem";
export const PricingTabs = lazy(() => import("./PricingTabs"));

export { default as FoundationType } from './DesignTabs/FoundationType';
export { default as InputParameters } from './DesignTabs/InputParameters/index.jsx';
export { default as Results } from './DesignTabs/Results/index.jsx';
export { default as SoilType } from './DesignTabs/SoilType';
export { default as LoadType } from './DesignTabs/LoadType';
export { default as SelectionSummary } from './DesignTabs/SelectionSummary';

export { default as TabButton } from './shared/TabButton';
export { default as GuidanceSection } from './shared/GuidanceSection';
export { default as SelectionBox } from './shared/SelectionBox';

export { default as FoundationDiagram } from './diagrams/FoundationDiagram.jsx';



//style.js
const styles = {  
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    
    heroHeadText:
      "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText:
      "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    
    sectionHeadText:
      "text-black font-bold md:text-[40px] sm:text-[30px] xs:text-[20px] text-[20px]",
    sectionSubText:
      "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider mt-4",
    sectionTitleText:
      "font-semibold text-black md:text-[24px] sm:text-[20px] xs:text-[18px] text-[16px]",
    sectionBodyText:
      "text-gray-700 sm:text-[16px] text-[14px] leading-relaxed",  
    sectionCardText:
      "text-gray-700 sm:text-[14px] text-[12px] leading-relaxed",  
    sectionGridThree:
      "grid grid-cols-1 md:grid-cols-3 gap-8 mt-12", 
    sectionGridFour:
      "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 mt-16",  
    sectionContainer:
      "max-w-6.5xl mx-auto text-center",
    sectionCard:
      "bg-white p-6 rounded-lg shadow-md",
    sectionNumberBadge:
      "w-10 h-10 text-md sm:w-12 sm:h-12 sm:text-lg bg-[#145da0] text-white rounded-full mx-auto flex items-center justify-center font-bold mb-4",
    cardTitle: "font-semibold text-gray-800 md:text-[18px] sm:text-[16px] text-[14px]",
    cardDescription: "text-gray-600 sm:text-[14px] text-[12px] mt-1",
    cardUseCase: "text-[#145da0] font-medium sm:text-[12px] text-[10px] mt-2",
  };
  
  export { styles };
